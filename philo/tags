!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
CC	Makefile	/^CC			= clang$/;"	m
CFLAGS	Makefile	/^CFLAGS		= -Wall -Wextra -Werror$/;"	m
MANDA_NAMES	Makefile	/^MANDA_NAMES	= conditions.c error.c ft_free.c ft_init.c ft_lst.c \\$/;"	m
MANDA_OBJS	Makefile	/^MANDA_OBJS	= $(MANDA_NAMES:.c=.o)$/;"	m
NAME	Makefile	/^NAME		= philosophers$/;"	m
PHILOSOPHERS_H	philosophers.h	/^# define PHILOSOPHERS_H$/;"	d
RM	Makefile	/^RM = rm -f$/;"	m
add_info_lst	ft_lst.c	/^void	add_info_lst(t_lst_philo *lst_philo, int info[])$/;"	f
begin	philosophers.h	/^	t_philo	*begin;$/;"	m	struct:s_lst_philo
color	philosophers.h	/^	char			*color;$/;"	m	struct:s_philo
condition_event	conditions.c	/^int	condition_event(void (*f)(t_philo*), t_philo *philo)$/;"	f
creat_lst	ft_lst.c	/^t_lst_philo	*creat_lst(t_lst_philo *lst_philo, int nbr_philo)$/;"	f
dead	philosophers.h	/^	int				dead;$/;"	m	struct:s_philo
destroy_mutex	ft_free.c	/^void	destroy_mutex(t_lst_philo *lst_philo)$/;"	f
eat	main_actions.c	/^void	eat(t_philo *philo)$/;"	f
end	philosophers.h	/^	t_philo	*end;$/;"	m	struct:s_lst_philo
end_pthread	ft_free.c	/^void	end_pthread(t_lst_philo *lst_philo)$/;"	f
event_loop	main_actions.c	/^void	*event_loop(void *p)$/;"	f
fork	philosophers.h	/^	t_fork			*fork;$/;"	m	struct:s_philo
fork	philosophers.h	/^	t_fork	*fork;$/;"	m	struct:s_lst_philo
free_destroy	ft_free.c	/^void	free_destroy(t_lst_philo *lst_philo)$/;"	f
free_lst_philo	ft_free.c	/^void	free_lst_philo(t_lst_philo *lst_philo)$/;"	f
ft_atoi	utils.c	/^int	ft_atoi(const char *str)$/;"	f
ft_sleep	main_actions.c	/^void	ft_sleep(t_philo *philo)$/;"	f
ft_strlen	utils.c	/^int	ft_strlen(char *str)$/;"	f
ft_think	main_actions.c	/^void	ft_think(t_philo *philo)$/;"	f
ft_time	utils.c	/^long	ft_time(void)$/;"	f
id	philosophers.h	/^	size_t			id;$/;"	m	struct:s_philo
if_dead	conditions.c	/^int	if_dead(t_philo *philo)$/;"	f
init_fork	ft_init.c	/^t_lst_philo	*init_fork(t_fork *fork, t_lst_philo *lst_philo, int nbr_philo)$/;"	f
init_info_lst	ft_init.c	/^void	init_info_lst(int ac, char **av, t_lst_philo *lst_philo)$/;"	f
init_sig	ft_init.c	/^void	init_sig(t_lst_philo *lst_philo, t_sig *sig)$/;"	f
is_dead	philosophers.h	/^	pthread_mutex_t	is_dead;$/;"	m	struct:s_sig
last_philo	philosophers.h	/^	size_t			last_philo;$/;"	m	struct:s_philo
lock	status.c	/^void	lock(t_philo *philo, int fork_first, int fork_second)$/;"	f
lst_add	ft_lst.c	/^t_lst_philo	*lst_add(t_lst_philo *lst_philo, int i)$/;"	f
lst_philo	philosophers.h	/^	void			*lst_philo;$/;"	m	struct:s_philo
main	philosophers.c	/^int	main(int ac, char **av)$/;"	f
mutex	philosophers.h	/^	pthread_mutex_t	mutex;$/;"	m	struct:s_fork
nbr_philo	philosophers.h	/^	int		nbr_philo;$/;"	m	struct:s_lst_philo
nbr_time_eat	philosophers.h	/^	unsigned int	nbr_time_eat;$/;"	m	struct:s_philo
next	philosophers.h	/^	struct s_philo	*next;$/;"	m	struct:s_philo	typeref:struct:s_philo::s_philo
order_fork	conditions.c	/^int	order_fork(t_philo *philo)$/;"	f
parsing_argument	error.c	/^void	parsing_argument(char **av)$/;"	f
philo	philosophers.h	/^	void			*philo;$/;"	m	struct:s_fork
philo_is_dead	secondary_actions.c	/^void	philo_is_dead(t_philo *philo, long time_past)$/;"	f
philo_is_eating	secondary_actions.c	/^void	philo_is_eating(t_philo *philo)$/;"	f
print_thread	status.c	/^void	print_thread(pthread_mutex_t *l, char *s, t_philo *ph)$/;"	f
s_fork	philosophers.h	/^typedef struct s_fork$/;"	s
s_lst_philo	philosophers.h	/^typedef struct s_lst_philo$/;"	s
s_philo	philosophers.h	/^typedef struct s_philo$/;"	s
s_sig	philosophers.h	/^typedef struct s_sig$/;"	s
sig	philosophers.h	/^	t_sig			*sig;$/;"	m	struct:s_philo
sig_dead	philosophers.h	/^	int				sig_dead;$/;"	m	struct:s_sig
slp	secondary_actions.c	/^void	slp(long nbr)$/;"	f
t_beg_lp	philosophers.h	/^	long			t_beg_lp;$/;"	m	struct:s_philo
t_fork	philosophers.h	/^}t_fork;$/;"	t	typeref:struct:s_fork
t_lst_philo	philosophers.h	/^}t_lst_philo;$/;"	t	typeref:struct:s_lst_philo
t_philo	philosophers.h	/^}t_philo;$/;"	t	typeref:struct:s_philo
t_sig	philosophers.h	/^}t_sig;$/;"	t	typeref:struct:s_sig
tab_fork	philosophers.h	/^	pthread_mutex_t	*tab_fork;$/;"	m	struct:s_fork
take_fork	secondary_actions.c	/^void	take_fork(t_philo *philo)$/;"	f
thread	philosophers.h	/^	pthread_t		thread;$/;"	m	struct:s_philo
time_begin	philosophers.h	/^	long			time_begin;$/;"	m	struct:s_philo
time_bf_eat	philosophers.h	/^	unsigned int	time_bf_eat;$/;"	m	struct:s_philo
time_diff	utils.c	/^long	time_diff(t_philo *philo)$/;"	f
time_end	philosophers.h	/^	long			time_end;$/;"	m	struct:s_philo
time_for_eat	philosophers.h	/^	unsigned int	time_for_eat;$/;"	m	struct:s_philo
time_to_sleep	philosophers.h	/^	unsigned int	time_to_sleep;$/;"	m	struct:s_philo
to_do	philosophers.c	/^void	*to_do(t_lst_philo *lst_philo)$/;"	f
unlock	status.c	/^void	unlock(t_philo *philo, int fork_first, int fork_second)$/;"	f
will_eat	secondary_actions.c	/^void	will_eat(t_philo *philo, int fork_first, int fork_second)$/;"	f
write_error	error.c	/^void	write_error(char *str)$/;"	f
